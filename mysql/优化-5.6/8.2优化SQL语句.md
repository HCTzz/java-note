## 8.2优化SQL语句

### 8.2.1优化SELECT语句

查询以[`SELECT`](https://dev.mysql.com/doc/refman/5.6/en/select.html) 语句的形式执行数据库中的所有查找操作。无论是实现动态网页的亚秒级响应时间，还是缩短时间以生成大量的隔夜报告，调整这些语句都是当务之急。

此外[`SELECT`](https://dev.mysql.com/doc/refman/5.6/en/select.html)语句，进行查询调谐技术也适用于结构，如 [`CREATE TABLE...AS SELECT`](https://dev.mysql.com/doc/refman/5.6/en/create-table-select.html)， [`INSERT INTO...SELECT`](https://dev.mysql.com/doc/refman/5.6/en/insert-select.html)和`WHERE`在条款 [`DELETE`](https://dev.mysql.com/doc/refman/5.6/en/delete.html)的语句。这些语句还有其他性能方面的考虑，因为它们将写操作与面向读取的查询操作结合在一起。

NDB Cluster支持联接下推优化，从而将符合条件的联接完整地发送到NDB Cluster数据节点，在该节点之间可以将其分布并并行执行。有关此优化的更多信息，请参见 [NDB下推连接的条件](https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions)。

优化查询的主要考虑因素是：

- 为了使慢速`SELECT ... WHERE`查询更快，首先要检查的是是否可以添加 [索引](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_index)。在`WHERE`子句中使用的列上设置索引，以加快评估，过滤和最终检索结果的速度。为避免浪费磁盘空间，请构造一小组索引，以加快应用程序中使用的许多相关查询的速度。

  对于使用[联接](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_join)和 [外键之类的](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_foreign_key)功能引用不同表的查询，索引尤其重要 。您可以使用该[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)语句来确定用于的索引 [`SELECT`](https://dev.mysql.com/doc/refman/5.6/en/select.html)。请参见 [第8.3.1节“ MySQL如何使用索引”](https://dev.mysql.com/doc/refman/5.6/en/mysql-indexes.html)和 [第8.8.1节“使用EXPLAIN优化查询”](https://dev.mysql.com/doc/refman/5.6/en/using-explain.html)。

- 隔离和调整查询中花费时间过多的任何部分，例如函数调用。根据查询的结构，可以对结果集中的每一行调用一次函数，甚至可以对表中的每一行调用一次函数，从而极大地提高了效率。

- 最小化 查询中[全表扫描](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_full_table_scan)的次数 ，尤其是对于大表。

- 通过[`ANALYZE TABLE`](https://dev.mysql.com/doc/refman/5.6/en/analyze-table.html)定期使用该语句来使表统计信息保持最新 ，因此优化器具有构建有效执行计划所需的信息。

- 了解每个表的存储引擎特定的调整技术，索引技术和配置参数。双方`InnoDB`并 `MyISAM`有两套准则的实现和维持查询高性能。有关详细信息，请参见[第8.5.6节“优化InnoDB查询”](https://dev.mysql.com/doc/refman/5.6/en/optimizing-innodb-queries.html)和 [第8.6.1节“优化MyISAM查询”](https://dev.mysql.com/doc/refman/5.6/en/optimizing-queries-myisam.html)。

- 您可以`InnoDB`使用[第8.5.3节“优化InnoDB只读事务”中](https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-ro-txn.html)的技术[优化](https://dev.mysql.com/doc/refman/5.6/en/innodb-performance-ro-txn.html)表的 单查询事务 。

- 避免以难以理解的方式转换查询，尤其是在优化程序自动执行某些相同转换的情况下。

- 如果使用基本准则之一不能轻松解决性能问题，请通过阅读[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)计划并调整索引，`WHERE`子句，连接子句等来调查特定查询的内部详细信息 。（当您达到一定的专业水平时，阅读 [`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)计划可能是每个查询的第一步。）

- 调整MySQL用于缓存的内存区域的大小和属性。由于有效地使用了 `InnoDB` [缓冲池](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_buffer_pool)， `MyISAM`键高速缓存和MySQL查询高速缓存，重复查询的运行速度更快，因为第二次及以后都从内存中检索了结果。

- 即使对于使用缓存区域快速运行的查询，您也可能会进一步优化，以使它们需要更少的缓存，从而使您的应用程序更具可伸缩性。可伸缩性意味着您的应用程序可以处理更多的并发用户，更大的请求等，而不会导致性能大幅下降。

- 处理锁定问题，其中其他会话同时访问表可能会影响查询速度。

#### 8.2.1.1 WHERE子句优化

本节讨论可以对处理`WHERE`子句进行的优化。这些示例使用 [`SELECT`](https://dev.mysql.com/doc/refman/5.6/en/select.html)语句，但是相同的优化适用`WHERE`于[`DELETE`](https://dev.mysql.com/doc/refman/5.6/en/delete.html)和 [`UPDATE`](https://dev.mysql.com/doc/refman/5.6/en/update.html)语句中的子句 。

注意

由于有关MySQL优化器的工作正在进行中，因此此处未记录MySQL执行的所有优化。

您可能会想重写查询以使算术运算更快，同时又牺牲了可读性。由于MySQL自动进行类似的优化，因此您通常可以避免这项工作，而将查询保留为更易于理解和维护的形式。MySQL执行的一些优化如下：

- 删除不必要的括号：

  ```sql
     ((a AND b) AND c OR (((a AND b) AND (c AND d))))
  -> (a AND b AND c) OR (a AND b AND c AND d)
  ```

- 恒定折叠：

  ```sql
     (a<b AND b=c) AND a=5
  -> b>5 AND b=c AND a=5
  ```

- 恒定条件消除：

  ```sql
     (b>=5 AND b=5) OR (b=6 AND 5=5) OR (b=7 AND 5=6)
  -> b=5 OR b=6
  ```

- 索引使用的常量表达式仅计算一次。

- [`COUNT(*)`](https://dev.mysql.com/doc/refman/5.6/en/aggregate-functions.html#function_count)上没有一个单一的表`WHERE`是从该表信息直接检索`MyISAM` 和`MEMORY`表。`NOT NULL`当仅与一个表一起使用时，对于任何表达式也将执行此操作。

- 早期检测无效的常量表达式。MySQL快速检测到某些 [`SELECT`](https://dev.mysql.com/doc/refman/5.6/en/select.html)语句是不可能的，并且不返回任何行。

- `HAVING``WHERE`如果您不使用`GROUP BY`或汇总功能（[`COUNT()`](https://dev.mysql.com/doc/refman/5.6/en/aggregate-functions.html#function_count)， [`MIN()`](https://dev.mysql.com/doc/refman/5.6/en/aggregate-functions.html#function_min)等），则与合并 。

- 对于联接中的每个表，`WHERE`都构造了一个更简单 `WHERE`的表以快速 评估该表，并尽快跳过行。

- 在查询中的任何其他表之前，首先读取所有常量表。常量表可以是以下任意一个：

  - 空表或具有一行的表。
  - 与a或 索引`WHERE` 上的子句一起使用的表，其中所有索引部分都与常量表达式进行比较，并定义为。 `PRIMARY KEY``UNIQUE``NOT NULL`

  以下所有表均用作常量表：

  ```sql
  SELECT * FROM t WHERE primary_key=1;
  SELECT * FROM t1,t2
    WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
  ```

- 通过尝试所有可能的方法，找到用于联接表的最佳联接组合。如果`ORDER BY`and`GROUP BY`子句中的所有列 都来自同一表，则在连接时优先使用该表。

- 如果存在一个`ORDER BY`子句和另一个`GROUP BY`子句，或者如果 `ORDER BY`或`GROUP BY` 包含联接队列中第一个表以外的表中的列，则会创建一个临时表。

- 如果使用`SQL_SMALL_RESULT` 修饰符，则MySQL使用内存中的临时表。

- 查询每个表索引，并使用最佳索引，除非优化程序认为使用表扫描更有效。一次使用扫描是基于最佳索引是否跨越了表的30％以上，但是固定百分比不再决定使用索引还是扫描。现在，优化器更加复杂，其估计基于其他因素，例如表大小，行数和I / O块大小。

- 在某些情况下，MySQL甚至可以在不查询数据文件的情况下从索引中读取行。如果索引中使用的所有列均为数字，则仅索引树用于解析查询。

- 在输出每一行之前，`HAVING`将跳过不匹配该子句的那些行 。

快速查询的一些示例：

```sql
SELECT COUNT(*) FROM tbl_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;

SELECT MAX(key_part2) FROM tbl_name
  WHERE key_part1=constant;

SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
```

假设索引列是数字，MySQL仅使用索引树来解析以下查询：

```sql
SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;

SELECT COUNT(*) FROM tbl_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tbl_name GROUP BY key_part1;
```

以下查询使用索引来按排序顺序检索行，而无需单独的排序遍历：

```sql
SELECT ... FROM tbl_name
  ORDER BY key_part1,key_part2,... ;

SELECT ... FROM tbl_name
  ORDER BY key_part1 DESC, key_part2 DESC, ... ;
```

#### 8.2.1.2范围优化

范围访问方法使用单个索引检索包含在一个或多个索引值间隔内的表行子集。它可以用于单个部分索引或多个部分索引。以下各节详细描述了如何从WHERE子句中提取间隔。

- [单部分索引的范围访问方法](https://dev.mysql.com/doc/refman/5.6/en/range-optimization.html#range-access-single-part)
- [多部分索引的范围访问方法](https://dev.mysql.com/doc/refman/5.6/en/range-optimization.html#range-access-multi-part)
- [多值比较的等距范围优化](https://dev.mysql.com/doc/refman/5.6/en/range-optimization.html#equality-range-optimization)

##### 单部分索引的范围访问方法

对于单部分索引，索引值间隔可以方便地由条款中的相应条件 `WHERE`表示，称为 范围条件， 而不是“间隔”。”

单部分索引的范围条件的定义如下：

- 对于`BTREE`和`HASH`索引，在使用 [`=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal)， [`<=>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal-to)， [`IN()`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_in)，[`IS NULL`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_is-null)或[`IS NOT NULL`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_is-not-null)运算符时，将键部分与常量值进行比较是一个范围条件。
- 另外，对于`BTREE`索引，使用[`>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than)， [`<`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_less-than)， [`>=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than-or-equal)， [`<=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_less-than-or-equal)， [`BETWEEN`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_between)， [`!=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal)、或[`<>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal) 运算符，或[`LIKE`](https://dev.mysql.com/doc/refman/5.6/en/string-comparison-functions.html#operator_like) 比较（如果[`LIKE`](https://dev.mysql.com/doc/refman/5.6/en/string-comparison-functions.html#operator_like) 的参数是不以通配符开头的常量字符串）。

- 对于所有索引类型，多个范围条件与`OR`或`AND`组合构成一个范围条件。

前面的描述中的“恒定值”表示以下之一：

- 查询字符串中的常量
- 来自同一联接 的[`const`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_const) 或[`system`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_system)表的 列
- 不相关子查询的结果
- 任何完全由上述类型的子表达式组成的表达式

以下是该`WHERE`子句中具有范围条件的查询示例：

```sql
SELECT * FROM t1
  WHERE key_col > 1
  AND key_col < 10;

SELECT * FROM t1
  WHERE key_col = 1
  OR key_col IN (15,18,20);

SELECT * FROM t1
  WHERE key_col LIKE 'ab%'
  OR key_col BETWEEN 'bar' AND 'foo';
```

在优化程序常数传播阶段，某些非常数值可以转换为常数。

MySQL尝试从`WHERE`子句中为每个可能的索引提取范围条件 。在提取过程中，删除了不能用于构建范围条件的条件，合并了产生重叠范围的条件，并删除了产生空范围的条件。

考虑下面的语句，其中 `key1`是索引列， `nonkey`而没有索引：

```sql
SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
```

密钥的提取过程`key1`如下：

1. 从原始`WHERE`子句开始：

   ```sql
   (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
   (key1 < 'bar' AND nonkey = 4) OR
   (key1 < 'uux' AND key1 > 'z')
   ```

2. 删除`nonkey = 4`，`key1 LIKE '%b'`因为它们不能用于范围扫描。删除它们的正确方法是将它们替换为`TRUE`，这样在进行范围扫描时我们不会丢失任何匹配的行。用`TRUE`产量代替它们：

   ```sql
   (key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
   (key1 < 'bar' AND TRUE) OR
   (key1 < 'uux' AND key1 > 'z')
   ```

3. 总是正确或错误的失败条件：

   - `(key1 LIKE 'abcde%' OR TRUE)` 永远是真的
   - `(key1 < 'uux' AND key1 > 'z')` 永远是假的

   用常量替换这些条件将产生：

   ```clike
   (key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
   ```

   删除不必要的真和假常量会产生：

   ```clike
   (key1 < 'abc') OR (key1 < 'bar')
   ```

4. 将重叠的间隔合并为一个可以得到用于范围扫描的最终条件：

   ```clike
   (key1 < 'bar')
   ```

一般而言（如前面的示例所示），范围扫描所使用的条件比该`WHERE`子句的限制要少。MySQL执行额外的检查，以筛选出满足范围条件但不满足完整`WHERE`子句的行。

范围条件提取算法可以处理 任意深度的嵌套 [`AND`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_and)/[`OR`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_or)构造，并且其输出不取决于条件在`WHERE`子句中出现的顺序 。

对于空间索引的范围访问方法，MySQL不支持合并多个范围。要解决此限制，可以使用具有相同SELECT语句的`UNION`，但将每个空间谓词放在不同的`SELECT`中。

##### 多部分索引的范围访问方法

多部分索引上的范围条件是单个部分索引范围条件的扩展。多部分索引上的范围条件限制索引行位于一个或多个键元组间隔内。使用索引中的排序，在一组键元组上定义键元组间隔。

例如，考虑一个定义为`key1`（*key_part1*、*key_part2*、*key_part3*）的多部分索引，以及按键顺序列出的以下一组键元组：

```clike
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
```

条件`key_part1=1`定义此间隔：

```clike
(1,-inf,-inf) <= (key_part1,key_part2,key_part3) < (1,+inf,+inf)
```

区间覆盖前面数据集中的第4、第5和第6元组，可由范围访问方法使用。

相比之下，条件`key_part3='abc'`没有定义单个间隔，并且不能被范围访问方法使用。

下面的描述更详细地说明了范围条件如何为多个部分索引工作。

- 对于`HASH`索引，可以使用包含相同值的每个间隔。这意味着只能针对以下形式的条件生成间隔：

  ```sql
      key_part1 cmp const1
  AND key_part2 cmp const2
  AND ...
  AND key_partN cmp constN;
  ```

  这里*`const1`*， *`const2`*...是常数，*`cmp`*是一个 [`=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal)， [`<=>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal-to)或者[`IS NULL`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_is-null)比较运营商，以及条件覆盖所有指数部分。（也就是说，存在*`N`* 条件，*`N`*-part索引的每个部分都有一个 条件。）例如，以下是三部分`HASH`索引的范围条件 ：

  ```sql
  key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
  ```

  有关被认为是常量的定义，请参见 [单部分索引的范围访问方法](https://dev.mysql.com/doc/refman/5.6/en/range-optimization.html#range-access-single-part)。

- 对于一个`BTREE`索引，以一定间隔可能是可用于条件组合 [`AND`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_and)，其中每个状态具有恒定值使用一个关键部分进行比较 [`=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal)， [`<=>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal-to)， [`IS NULL`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_is-null)， [`>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than)， [`<`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_less-than)， [`>=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than-or-equal)， [`<=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_less-than-or-equal)， [`!=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal)， [`<>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal)， [`BETWEEN`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_between)，或 （其中 [`LIKE '*`pattern`*'`](https://dev.mysql.com/doc/refman/5.6/en/string-comparison-functions.html#operator_like)`'*`pattern`*'` 不以通配符开头）。只要可以确定一个包含所有与条件匹配的行的单个键元组，就可以使用一个间隔（如果使用[`<>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal) 或，[`!=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal) 则使用两个间隔 ）。

  只要比较运算符为，或[`=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal)， 优化器就会尝试使用其他关键部分来确定间隔 。如果操作是 ， ， ， ， ， ， ，或者 ，优化器使用它，但认为没有更多的关键部分。对于以下表达式，优化器使用 第一个比较中的值。它也使用 [`<=>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal-to)[`IS NULL`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_is-null)[`>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than)[`<`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_less-than)[`>=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than-or-equal)[`<=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_less-than-or-equal)[`!=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal)[`<>`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_not-equal)[`BETWEEN`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_between)[`LIKE`](https://dev.mysql.com/doc/refman/5.6/en/string-comparison-functions.html#operator_like)[`=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_equal)[`>=`](https://dev.mysql.com/doc/refman/5.6/en/comparison-operators.html#operator_greater-than-or-equal) 根据第二个比较，但不考虑其他关键部分，并且不将第三个比较用于区间构造：

  ```sql
  key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
  ```

  单个间隔为：

  ```sql
  ('foo',10,-inf) < (key_part1,key_part2,key_part3) < ('foo',+inf,+inf)
  ```

  创建的间隔可能包含比初始条件更多的行。例如，前面的时间间隔包含`('foo', 11, 0)`不满足原始条件的值。

- 如果将覆盖间隔中包含的行集合的条件与组合[`OR`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_or)，则它们将形成覆盖间隔中的并 集中包含的行集合的条件。如果条件与组合 [`AND`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_and)，则它们将形成一个条件，该条件覆盖其间隔的交点内包含的一组行。例如，对于由两部分组成的索引的这种情况：

  ```sql
  (key_part1 = 1 AND key_part2 < 2) OR (key_part1 > 5)
  ```

  间隔为：

  ```sql
  (1,-inf) < (key_part1,key_part2) < (1,2)
  (5,-inf) < (key_part1,key_part2)
  ```

  在此示例中，第一行的间隔使用一个关键部分作为左边界，使用两个关键部分作为右边界。第二行的间隔仅使用一个关键部分。输出中的`key_len`列[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)指示所使用的密钥前缀的最大长度。

  在某些情况下，`key_len`可能表明已使用了关键部件，但这可能不是您期望的。假设 *`key_part1`*和 *`key_part2`*可以是 `NULL`。然后，该 `key_len`列显示以下条件的两个关键零件长度：

  ```sql
  key_part1 >= 1 AND key_part2 < 2
  ```

  但是，实际上，条件已转换为：

  ```sql
  key_part1 >= 1 AND key_part2 IS NOT NULL
  ```

有关如何执行优化以合并或消除单部分索引上范围条件的间隔的描述，请参见单部分索引的 [范围访问方法](https://dev.mysql.com/doc/refman/5.6/en/range-optimization.html#range-access-single-part)。针对多部分索引上的范围条件执行类似的步骤。

##### 多值比较的等距范围优化

考虑以下表达式，其中 *`col_name`*是索引列：

```sql
col_name IN(val1, ..., valN)
col_name = val1 OR ... OR col_name = valN
```

如果*`col_name`*等于多个值中的任何一个，则每个表达式为true 。这些比较是相等范围比较（“范围”是单个值）。优化器估算读取相等行以进行相等范围比较的成本，如下所示：

- 如果在上有唯一索引 *`col_name`*，则每个范围的行估计为1，因为最多一行可以具有给定值。
- 否则，任何索引 *`col_name`*都不是唯一的，优化器可以使用对索引或索引统计的深入估算来估计每个范围的行数。



使用索引下潜，优化器在一个范围的每一端进行一次下潜，并使用该范围中的行数作为估计值。例如，`（10，20，30）`中的表达式col_name有三个相等范围，优化器对每个范围进行两次下移以生成行估计值。每对分解生成具有给定值的行数的估计值。

索引下潜提供了精确的行估计值，但是随着表达式中比较值的数量增加，优化器生成行估计值的时间会更长。使用索引统计信息比索引剥离更不精确，但允许对大值列表进行更快的行估计。

 [`eq_range_index_dive_limit`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_eq_range_index_dive_limit)系统变量可用于配置优化器从一个行估计策略切换到另一个行估计策略的值的数量。要允许使用索引下潜来比较多达N个相等范围，请将`eq_range_index_dive_limit`设置为`N+1`。要禁用统计信息的使用并始终使用索引下潜而不考虑N，请将`eq_range_index_dive_limit`设置为0。

要更新表索引统计信息以获得最佳估计值，请使用 [`ANALYZE TABLE`](https://dev.mysql.com/doc/refman/5.6/en/analyze-table.html)。

即使在使用索引下潜的情况下，满足所有这些条件的查询也会跳过索引下潜：

- 存在单个索引`FORCE INDEX`索引提示。其想法是，如果强制使用索引，那么执行索引的额外开销将一无所获。
- 索引不唯一，不是全文索引（`FULLTEXT`）。
- 不存在子查询。
- 不存在`DISTINCT`、`GROUP BY`或`ORDER BY`子句。。

这些跳转条件只适用于单表查询。对于多个表查询（联接），不会跳过索引下潜。

#### 8.2.1.3索引合并优化

Index Merge access方法检索具有多个范围扫描的行，并将它们的结果合并为一个。此访问方法只合并来自单个表的索引扫描，而不是跨多个表的扫描。合并可以生成其底层扫描的并集、交集或交集的并集。

可以使用索引合并的查询示例：

```sql
SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;

SELECT * FROM tbl_name
  WHERE (key1 = 10 OR key2 = 20) AND non_key = 30;

SELECT * FROM t1, t2
  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')
  AND t2.key1 = t1.some_col;

SELECT * FROM t1, t2
  WHERE t1.key1 = 1
  AND (t2.key1 = t1.some_col OR t2.key2 = t1.some_col2);
```

注意

索引合并优化算法具有以下已知限制：

- 如果查询有一个复杂的WHERE子句，其中包含深度[`AND`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_and)/[`OR`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_or) 嵌套的复杂子句，并且MySQL没有选择最佳计划，请尝试使用以下标识转换分发术语：

  ```sql
  (x AND y) OR z => (x OR z) AND (y OR z)
  (x OR y) AND z => (x AND z) OR (y AND z)
  ```

- 索引合并不适用于全文索引。

在[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)输出中，索引合并方法出现 [`index_merge`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_index_merge)在 `type`列中。在这种情况下，该 `key`列包含使用的索引列表，并`key_len`包含这些索引的最长键部分的列表。

索引合并访问方法具有几种算法，这些算法显示在输出`Extra`字段中 [`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)：

- `Using intersect(...)`
- `Using union(...)`
- `Using sort_union(...)`

下面的部分将更详细地描述这些算法。优化器根据各种可用选项的成本估计，在不同可能的索引合并算法和其他访问方法之间进行选择。

索引合并的使用取决于[`optimizer_switch`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_optimizer_switch)系统变量的 `index_merge`， `index_merge_intersection`， `index_merge_union`，和 `index_merge_sort_union`标志的值。请参见[第8.9.2节“可切换的优化”](https://dev.mysql.com/doc/refman/5.6/en/switchable-optimizations.html)。默认情况下，所有这些标志都处于启用`on`状态。若要仅启用某些算法，请将`index_merge`设置为off，并仅启用应允许的其他算法。

- [索引合并交叉访问算法](https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html#index-merge-intersection)
- [索引合并联合访问算法](https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html#index-merge-union)
- [索引合并排序联合访问算法](https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html#index-merge-sort-union)

##### 索引合并交叉访问算法

当`WHERE`子句在与键组合在一起的不同键上转换为多个范围条件 [`AND`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_and)，并且每个条件是以下条件之一时，此访问算法适用 ：

- *`N`*这种形式 的-part表达式，其中索引具有完全相同的 *`N`*部分（即，所有索引部分均被覆盖）：

  ```sql
  key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN
  ```

- `InnoDB`表 主键上的任何范围条件 。

例子：

```sql
SELECT * FROM innodb_table
  WHERE primary_key < 10 AND key_col1 = 20;

SELECT * FROM tbl_name
  WHERE key1_part1 = 1 AND key1_part2 = 2 AND key2 = 2;
```

索引合并交集算法对所有使用的索引执行同时扫描，并生成从合并索引扫描接收到的行序列的交集。

如果查询中使用的所有列都被使用的索引覆盖，则不会检索完整的表行（ 在这种情况下，[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)输出包含 `Using index`在`Extra`字段中）。这是此类查询的示例：

```sql
SELECT COUNT(*) FROM t1 WHERE key1 = 1 AND key2 = 1;
```

如果使用的索引未覆盖查询中使用的所有列，则仅在满足所有使用的键的范围条件时才检索完整行。

如果合并的条件之一是`InnoDB`表主键上的条件，则该条件不用于行检索，而是用于过滤出使用其他条件检索的行。

##### 索引合并联合访问算法

该算法的标准类似于索引合并交集算法的标准。当表的`WHERE` 子句在与键组合在一起的不同键上转换为多个范围条件[`OR`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_or)，并且每个条件是以下条件之一时，该算法适用：

- *`N`*这种形式 的-part表达式，其中索引具有完全相同的 *`N`*部分（即，所有索引部分均被覆盖）：

  ```sql
  key_part1 = const1 AND key_part2 = const2 ... AND key_partN = constN
  ```

- `InnoDB`表 主键上的任何范围条件 。

- 索引合并交集算法适用的条件。

例子：

```sql
SELECT * FROM t1
  WHERE key1 = 1 OR key2 = 2 OR key3 = 3;

SELECT * FROM innodb_table
  WHERE (key1 = 1 AND key2 = 2)
     OR (key3 = 'foo' AND key4 = 'bar') AND key5 = 5;
```

##### 索引合并排序联合访问算法

当从`WHERE`子句转换为多个范围条件 时，此访问算法适用 [`OR`](https://dev.mysql.com/doc/refman/5.6/en/logical-operators.html#operator_or)，但索引合并并集算法不适用。

例子：

```sql
SELECT * FROM tbl_name
  WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name
  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col = 30;
```

排序联合算法和联合算法之间的区别在于，排序联合算法必须首先获取所有行的行ID，然后对它们进行排序，然后再返回任何行。

#### 8.2.1.4存储引擎下推优化

这种优化提高了非索引列和常量之间直接比较的效率。在这种情况下，条件被“下推”到存储引擎进行评估。此优化只能由[`NDB`](https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster.html)存储引擎使用。	

对于NDB群集，此优化可以消除在群集的数据节点与发出查询的MySQL服务器之间通过网络发送不匹配的行的需求，并且可以但不使用条件下推的地方将查询的速度提高5到10倍。

假设NDB群集表定义如下：

```sql
CREATE TABLE t1 (
    a INT,
    b INT,
    KEY(a)
) ENGINE=NDB;
```

条件下推可用于查询，例如此处显示的查询，其中包括未索引列与常量之间的比较：

```sql
SELECT a, b FROM t1 WHERE b = 10;
```

条件下推的使用可以在以下输出中看到[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)：

```sql
mysql> EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
```

但是，引擎条件下推*不能* 与以下两个查询之一一起使用：

```sql
SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
```

引擎条件下推不适用于第一个查询，因为column上存在索引`a`。（索引访问方法将更有效，因此将优先选择条件下推。）引擎条件下推不能用于第二个查询，因为涉及非索引列的比较 `b`是间接的。（但是，如果`b + 1 = 10`要`b = 9`在`WHERE`条款中减少到，则 可以应用引擎条件下推。）

当使用`>`或`<`运算符将索引列与常量进行比较时，也可以使用引擎条件下推 ：

```sql
mysql> EXPLAIN SELECT a, b FROM t1 WHERE a < 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: range
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 2
        Extra: Using where with pushed condition
```

其他支持的发动机状态下推比较包括：

- `column [NOT] LIKE pattern`

  *`pattern`*必须是包含要匹配的模式的字符串文字；有关语法，请参见[第12.8.1节“字符串比较函数和运算符”](https://dev.mysql.com/doc/refman/5.6/en/string-comparison-functions.html)。

- `column IS [NOT] NULL`

- `column IN (value_list)`

  中的每个项目都*`value_list`* 必须是恒定的文字值。

- `*`column`* BETWEEN *`constant1`* AND *`constant2`*`

  *`constant1`*并且 *`constant2`*每个值都必须是恒定的文字值。

在上述列表中的所有情况下，都有可能将条件转换为列与常量之间的一个或多个直接比较的形式。

默认情况下，引擎状态下推处于启用状态。要在服务器启动时禁用它，请将 [`optimizer_switch`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_optimizer_switch)系统变量的`engine_condition_pushdown` 标志设置为`off`。例如，在`my.cnf`文件中，使用以下几 行：

```ini
[mysqld]
optimizer_switch=engine_condition_pushdown=off
```

在运行时，禁用条件下推，如下所示：

```sql
SET optimizer_switch='engine_condition_pushdown=off';
```

**局限性。** 

引擎状态下推受以下限制：

- 引擎状态下推仅受[`NDB`](https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster.html)存储引擎支持 。
- 列只能与常量进行比较；但是，这包括计算结果为常数的表达式。
- 比较中使用的列不能为 [`BLOB`](https://dev.mysql.com/doc/refman/5.6/en/blob.html)或 [`TEXT`](https://dev.mysql.com/doc/refman/5.6/en/blob.html)类型。此排除范围也扩展到[`BIT`](https://dev.mysql.com/doc/refman/5.6/en/bit-type.html)和 [`ENUM`](https://dev.mysql.com/doc/refman/5.6/en/enum.html)列。
- 要与列进行比较的字符串值必须使用与列相同的排序规则。
- 不直接支持联接。涉及多个表的条件将在可能的情况下分别推送。使用扩展[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)输出来确定实际推低了哪些条件。请参见 [第8.8.3节“扩展的EXPLAIN输出格式”](https://dev.mysql.com/doc/refman/5.6/en/explain-extended.html)。



#### 8.2.1.5索引条件下推优化

索引条件下推（ICP）是针对MySQL使用索引从表中检索行的情况的一种优化。如果不使用ICP，则存储引擎将遍历索引以在基表中定位行，并将其返回给MySQL服务器，后者将评估`WHERE`行的条件。启用ICP后，如果`WHERE`可以仅使用索引中的列来评估部分 条件，则MySQL服务器会将这部分条件压入`WHERE`条件下降到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且只有在满足此条件的情况下，才从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。

索引条件下推式优化的适用性取决于以下条件：

- ICP用于 [`range`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_range)， [`ref`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref)， [`eq_ref`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_eq_ref)，和 [`ref_or_null`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_ref_or_null)访问方法时，有一个需要访问的全部表行。
- ICP可用于[`InnoDB`](https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html) 和[`MyISAM`](https://dev.mysql.com/doc/refman/5.6/en/myisam-storage-engine.html)表。（例外：MySQL 5.6中的分区表不支持ICP； MySQL 5.7中已解决此问题。）
- 对于`InnoDB`表，ICP仅用于二级索引。ICP的目标是减少全行读取的次数，从而减少I / O操作。对于 `InnoDB`聚集索引，完整的记录已被读入`InnoDB` 缓冲区。在这种情况下使用ICP不会减少I / O。
- 引用子查询的条件不能下推。
- 涉及`functions`的条件不能下推。存储引擎无法调用`functions`的功能。
- 触发条件不能下推。（有关触发条件的信息，请参见 [第8.2.2.3节“使用EXISTS策略优化子查询”）](https://dev.mysql.com/doc/refman/5.6/en/subquery-optimization-with-exists.html)。

要了解此优化的工作原理，请首先考虑在不使用“索引条件下推”的情况下如何进行索引扫描：

1. 获取下一行，首先读取索引元组，然后使用索引元组查找并读取整个表行。
2. 测试`WHERE`适用于此表的部分条件。根据测试结果接受或拒绝该行。

使用“索引条件下推”，扫描将改为这样进行：

1. 获取下一行的索引元组（而不是整个表行）。
2. 测试`WHERE`适用于此表的部分条件，并且只能使用索引列进行检查。如果不满足条件，请转到下一行的索引元组。
3. 如果满足条件，请使用索引元组来定位和读取整个表行。
4. 测试`WHERE` 适用于此表的条件的其余部分。根据测试结果接受或拒绝该行。

[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)当使用“索引条件下推”时，输出将显示 `Using index condition`在 `Extra`列中。它不会显示，`Using index` 因为在必须读取完整表行时，该方法不适用。

假设一个表包含有关人员及其地址的信息，并且该表的索引定义为 `INDEX (zipcode, lastname, firstname)`。如果我们知道一个人的`zipcode`的值，但不确定姓氏，可以这样搜索：

```sql
SELECT * FROM people
  WHERE zipcode='95054'
  AND lastname LIKE '%etrunia%'
  AND address LIKE '%Main Street%';
```

MySQL可以使用索引扫描满足 `zipcode='95054'的记录`。第二部分（`lastname LIKE '%etrunia%'`）不能用于限制必须扫描的行数，因此，如果没有“索引条件下推”，此查询必须为所有具有条件的人检索完整的表行 `zipcode='95054'`。

通过“索引条件下推”，MySQL`lastname LIKE '%etrunia%'`在读取整个表行之前会检查该 部分。这样可以避免读取与`zipcode`条件而不是 `lastname`条件匹配的索引元组对应的完整行 。

默认情况下，索引条件下推处于启用状态。可以[`optimizer_switch`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_optimizer_switch)通过设置`index_condition_pushdown`标志来使用系统变量 进行控制 ：

```sql
SET optimizer_switch = 'index_condition_pushdown=off';
SET optimizer_switch = 'index_condition_pushdown=on';
```

请参见[第8.9.2节“可切换的优化”](https://dev.mysql.com/doc/refman/5.6/en/switchable-optimizations.html)。

#### 8.2.1.6嵌套循环联接算法

MySQL使用嵌套循环算法或其上的变体在表之间执行联接。

- [嵌套循环联接算法](https://dev.mysql.com/doc/refman/5.6/en/nested-loop-joins.html#nested-loop-join-algorithm)
- [块嵌套循环连接算法](https://dev.mysql.com/doc/refman/5.6/en/nested-loop-joins.html#block-nested-loop-join-algorithm)

##### 嵌套循环联接算法

一种简单的嵌套循环联接（NLJ）算法一次从一个循环中的第一个表中读取行，然后将每一行传递给一个嵌套循环，该循环处理联接中的下一个表。重复此过程的次数与要连接的表的次数相同。

假定将使用以下联接类型执行三个表`t1`，`t2`和 之间的 `t3`联接：

```none
Table   Join Type
t1      range
t2      ref
t3      ALL
```

如果使用简单的NLJ算法，则按以下方式处理联接：

```clike
for each row in t1 matching range {
  for each row in t2 matching reference key {
    for each row in t3 {
      if row satisfies join conditions, send to client
    }
  }
}
```

因为NLJ算法从外循环到内循环一次传递一行，所以它通常会多次读取在内循环中处理的表。

##### 块嵌套循环连接算法

块嵌套循环（BNL）嵌套算法使用对在外部循环中读取的行的缓冲来减少必须读取内部循环中的表的次数。例如，如果将10行读入缓冲区并将缓冲区传递到下一个内部循环，则可以将内部循环中读取的每一行与缓冲区中的所有10行进行比较。这将内部表必须读取的次数减少了一个数量级。

MySQL连接缓冲具有以下特征：

- 当连接的类型为[`ALL`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_all)或是 [`index`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_index)（换句话说，无法使用可能的键，并且分别对数据行或索引行进行完整扫描 时），可以使用连接缓冲 [`range`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_range)。缓冲的使用也适用于外部联接，如[第8.2.1.11节“阻止嵌套循环和批处理键访问联接”所述](https://dev.mysql.com/doc/refman/5.6/en/bnl-bka-optimization.html)。
- 连接缓冲区永远不会分配给第一个非恒定表，即使它的类型是 [`ALL`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_all)或 [`index`](https://dev.mysql.com/doc/refman/5.6/en/explain-output.html#jointype_index)。
- 联接中只有感兴趣的列存储在其联接缓冲区中，而不是整个行。
- [`join_buffer_size`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_join_buffer_size)系统变量确定用于处理查询的每个联接缓冲区的大小。
- 为每个可以缓冲的联接分配一个缓冲区，因此可以使用多个联接缓冲区来处理给定的查询。
- 联接缓冲区在执行联接之前分配，并在查询完成后释放。

对于先前为NLJ算法描述的示例连接（不带缓冲），使用连接缓冲按如下方式进行连接：

```clike
for each row in t1 matching range {
  for each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    if buffer is full {
      for each row in t3 {
        for each t1, t2 combination in join buffer {
          if row satisfies join conditions, send to client
        }
      }
      empty join buffer
    }
  }
}

if buffer is not empty {
  for each row in t3 {
    for each t1, t2 combination in join buffer {
      if row satisfies join conditions, send to client
    }
  }
}
```

如果S是连接缓冲区中存储的每个t1、t2组合的大小，C是缓冲区中的组合数，则扫描t3表的次数为：

```clike
(S * C)/join_buffer_size + 1
```

t3扫描的次数随着[`join_buffer_size`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_join_buffer_size)的值增加而减少，直到[`join_buffer_size`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_join_buffer_size)足够大以容纳所有以前的行组合为止。那时，通过增大它无法获得速度提升的。

#### 8.2.1.7嵌套联接优化

表达联接的语法允许嵌套联接。以下讨论涉及[第13.2.9.2节“ JOIN子句”中](https://dev.mysql.com/doc/refman/5.6/en/join.html)描述的[联接](https://dev.mysql.com/doc/refman/5.6/en/join.html)语法 。

与SQL标准相比，扩展了*`table_factor`*的语法。后者只接受*`table_reference`*，而不接受括号内的列表。如果我们将*`table_reference`*项列表中的每个逗号都视为内部联接，则这是一个保守的扩展。例如：

```sql
SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
```

等效于：

```sql
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
```

在MySQL中，`CROSS JOIN`在语法上等同于`INNER JOIN`；它们可以相互替换。在标准SQL中，它们是不等价的。`INNER JOIN`与`ON`子句一起使用；否则使用`CROSS JOIN`。

通常，在仅包含内部联接操作的联接表达式中可以忽略括号。考虑以下联接表达式：

```sql
t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
```

在除去括号和左侧的分组操作之后，该join表达式将转换为该表达式：

```sql
(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
```

但是，这两种表达方式并不相等。看到这一点，假设表`t1`， `t2`以及`t3`具有以下状态：

- 表`t1`包含行 `(1)`，`(2)`
- 表`t2`包含行 `(1,101)`
- 表`t3`包含行 `(101)`

在这种情况下，第一个表达式返回结果集包括行`(1,1,101,101)`， `(2,NULL,NULL,NULL)`，而第二表达式返回的行`(1,1,101,101)`， `(2,NULL,NULL,101)`：

```sql
mysql> SELECT *
       FROM t1
            LEFT JOIN
            (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
            ON t1.a=t2.a;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql> SELECT *
       FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)
            LEFT JOIN t3
            ON t2.b=t3.b OR t2.b IS NULL;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
```

在以下示例中，将外部联接操作与内部联接操作一起使用：

```sql
t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
```

该表达式不能转换为以下表达式：

```sql
t1 LEFT JOIN t2 ON t1.a=t2.a, t3
```

对于给定的表状态，两个表达式返回不同的行集：

```sql
mysql> SELECT *
       FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql> SELECT *
       FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
```

因此，如果我们在使用外部联接运算符的联接表达式中省略括号，则可能会更改原始表达式的结果集。

更确切地说，我们不能忽略左外部联接操作的右操作数和右联接操作的左操作数的括号。换句话说，我们不能忽略外部联接操作的内部表表达式的括号。另一个操作数（外部表的操作数）的括号可以忽略。

下面的表达式：

```sql
(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
```

对于任何表`t1,t2,t3`以及`P`属性`t2.b` 和条件上的任何条件 ，该表达式均等效于此表达式 `t3.b`：

```sql
t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
```

每当连接表达式（*`joined_table`*）中的连接操作执行顺序不是从左到右时，我们都在谈论嵌套连接。考虑以下查询：

```sql
SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a > 1

SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a > 1
```

这些查询被认为包含以下嵌套联接：

```sql
t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
```

在第一个查询中，嵌套联接是通过左联接操作形成的。在第二个查询中，它由内部联接操作形成。

在第一个查询中，可以省略括号：联接表达式的语法结构将规定联接操作的执行顺序。对于第二个查询，尽管可以在没有括号的情况下明确解释此处的连接表达式，但不能省略括号。在我们的扩展语法中，`(t2, t3)`第二个查询的括号是必需的，尽管从理论上讲可以在没有括号的情况下对其进行解析：由于查询`LEFT JOIN`并`ON` 在表达式的左右定界符中起着作用，因此查询仍然具有明确的句法结构`(t2,t3)`。

前面的示例说明了以下几点：

- 对于仅涉及内部联接（而不涉及外部联接）的联接表达式，可以删除括号并从左到右评估联接。实际上，可以按任何顺序评估表。
- 通常，对于外部联接或与内部联接混合的外部联接，情况并非如此。删除括号可能会改变结果。



具有嵌套外部联接的查询的执行方式与具有内部联接的查询的执行方式相同。更确切地说，利用了嵌套循环联接算法的变体。调用[嵌套循环联接](https://dev.mysql.com/doc/refman/5.6/en/nested-loop-joins.html)执行查询的算法（请参见[第8.2.1.6节“嵌套循环联接算法”](https://dev.mysql.com/doc/refman/5.6/en/nested-loop-joins.html)）。假设对3个表的联接查询`T1,T2,T3`具有以下形式：

```sql
SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3)
```

在这里，`P1(T1,T2)`和 `P2(T3,T3)`是一些连接条件（在表达式上），而是`P(T1,T2,T3)`在table的列上的条件`T1,T2,T3`。

嵌套循环联接算法将以以下方式执行此查询：

```clike
FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
```

符号`t1||t2||t3`表示通过连接的行的列构成的行 `t1`，`t2`和 `t3`。在以下某些示例中， `NULL`出现表名的地方是指`NULL`该表的每一列都使用一行。例如，`t1||t2||NULL` 表示通过将行`t1`和的列`t2`以及 `NULL`的每一列 串联而构造的行`t3`。据说这样的行是 `NULL`互补的。



现在考虑一个带有嵌套外部联接的查询：

```sql
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3)
```

对于此查询，修改嵌套循环模式以获得：

```clike
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
```

通常，对于外部联接操作中第一个内部表的任何嵌套循环，都会引入一个标志，该标志在循环之前关闭并在循环之后检查。当针对外部表中的当前行找到表示内部操作数的表中的匹配项时，将打开该标志。如果在循环周期结束时该标志仍处于关闭状态，则未找到外部表的当前行的匹配项。在这种情况下，该行由`NULL`内部表的列的值补充 。结果行将传递到输出的最终检查项或下一个嵌套循环，但前提是该行满足所有嵌入式外部联接的联接条件。

在该示例中，嵌入了以下表达式表示的外部联接表：

```sql
(T2 LEFT JOIN T3 ON P2(T2,T3))
```

对于具有内部联接的查询，优化器可以选择不同顺序的嵌套循环，例如：

```clike
FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
```

对于具有外部联接的查询，优化器只能选择以下顺序：外部表的循环优先于内部表的循环。因此，对于带有外部联接的查询，只能使用一个嵌套顺序。对于以下查询，优化器将评估两个不同的嵌套。在这两个嵌套中， `T1`必须在外部循环中进行处理，因为它在外部联接中使用。`T2`和 `T3`在内部联接中使用，因此联接必须在内部循环中处理。但是，由于联接是内部联接，`T2`因此 `T3`可以按任何顺序进行处理。

```sql
SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
```

一个嵌套计算`T2`，然后 `T3`：

```clike
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
```

另一个嵌套计算`T3`，则 `T2`：

```clike
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
```

在讨论内部联接的嵌套循环算法时，我们省略了一些细节，这些细节对查询执行性能的影响可能很大。我们没有提到所谓的 “下推”条件。假设我们的 `WHERE`条件 `P(T1,T2,T3)`可以用一个联合公式表示：

```clike
P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
```

在这种情况下，MySQL实际上使用以下嵌套循环算法通过内部联接执行查询：

```clike
FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
```

你看，每个合取的`C1(T1)`， `C2(T2)`，`C3(T3)`是最内环的推到最外环的地方进行评估。如果`C1(T1)`是非常严格的条件，则此条件下推可能会大大减少表中`T1` 传递给内部循环的行数。结果，查询的执行时间可以大大改善。

对于具有外部联接的查询，`WHERE` 仅在发现外部表的当前行在内部表中具有匹配项之后，才检查条件。因此，将条件从内部嵌套循环中推出的优化不能直接应用于具有外部联接的查询。在这里，我们必须引入条件下推谓词，该条件下推谓词由遇到匹配时打开的标志保护。

回想一下带有外部联接的示例：

```clike
P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
```

对于该示例，使用受保护的下推条件的嵌套循环算法如下所示：

```clike
FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&&f2?C3(t3):TRUE) {
      IF (f1&&f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) && P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 && P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
```

通常，可以从诸如`P1(T1,T2)`和的 连接条件中提取下推谓词`P(T2,T3)`。在这种情况下，下推谓词也由一个标志来保护，该标志防止检查谓词中`NULL`由相应外部联接操作生成的-补行。

如果是由`WHERE`条件谓词引起的，则禁止在同一嵌套连接中通过键从一个内部表访问另一个内部表。

#### 8.2.1.8外部联接优化

外部联接包括`LEFT JOIN`和 `RIGHT JOIN`。

MySQL实现如下： `*`A`* LEFT JOIN *`B`* *`join_specification`*`

- 表`B`被设置为依赖于表`A`和`A`所依赖的所有表。
- 表`A`被设置为依赖于`LEFT JOIN`条件中使用的所有表（B除外）。
- 该`LEFT JOIN`条件用于确定如何从table中检索行 *`B`*。（换句话说，`WHERE`不使用该子句中的任何条件。）
- 执行所有标准的连接优化，不同之处在于始终在表所依赖的所有表之后读取该表。如果存在循环依赖关系，则会发生错误。
- `WHERE`执行 所有标准优化。
- 如果其中有一行*`A`*与该`WHERE`子句匹配，但没有一行*`B`*与该`ON`条件匹配 ，*`B`*则会生成一个额外的 行，且所有列都设置为`NULL`。
- 如果`LEFT JOIN`用于查找某张表中不存在的行，并且进行了以下测试：`*`col_name`* IS NULL`在该`WHERE`部分中，哪里 *`col_name`*是声明为的列`NOT NULL`，MySQL在找到后会停止搜索更多行（针对特定的键组合）符合`LEFT JOIN`条件的一行。
- 如果使用`LEFT JOIN`来查找某些表中不存在的行，并且进行了以下测试：`col_name`在`WHERE`部分为`NULL`，其中`col_name`是声明为`not NULL`的列，那么MySQL在找到一行与`LEFT JOIN`条件匹配的行后，停止搜索更多行（对于特定的键组合）。

该`RIGHT JOIN`实现类似于`LEFT JOIN`表角色相反的实现。如[第8.2.1.9节“简化外部连接”](https://dev.mysql.com/doc/refman/5.6/en/outer-join-simplification.html)所述，将右连接转换为等效的左连接。

对于`LEFT JOIN`，如果 `WHERE`条件对于生成的`NULL`行始终为false ，则将`LEFT JOIN`其更改为内部联接。例如， `WHERE`如果条款是在下面的查询错误的`t2.column1`是 `NULL`：

```sql
SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
```

因此，将查询转换为内部联接是安全的：

```sql
SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
```



现在，如果这样做会导致更好的查询计划，那么优化器可以`t2`先于表使用表`t1`。要提供有关表连接顺序的提示，请使用`STRAIGHT_JOIN`；请参见 [第13.2.9节“ SELECT语句”](https://dev.mysql.com/doc/refman/5.6/en/select.html)。但是，`STRAIGHT_JOIN`由于它禁用了半联接转换，因此 可能会阻止使用索引。请参见 [第8.2.2.1节“使用半联接转换优化子查询”](https://dev.mysql.com/doc/refman/5.6/en/semijoins.html)。

现在，优化器可以在表`t1`之前使用表`t2`，如果这样做会产生更好的查询计划。要提供关于表联接顺序的提示，请使用`STRAIGHT_join`；请参阅 [第13.2.9节“ SELECT语句”](https://dev.mysql.com/doc/refman/5.6/en/select.html)。但是，`STRAIGHT_JOIN`可能会阻止使用索引，因为它禁用半连接转换；请参见 [第8.2.2.1节“使用半联接转换优化子查询”](https://dev.mysql.com/doc/refman/5.6/en/semijoins.html)。

#### 8.2.1.9外部联接简化

在一个查询的许多情况下，子句的表达式都是经过简化的。

在解析器阶段，具有右外部联接操作的查询将转换为仅包含左联接操作的等效查询。在一般情况下，执行转换时要进行以下右连接：

```sql
(T1, ...) RIGHT JOIN (T2, ...) ON P(T1, ..., T2, ...)
```

成为以下等效的左联接：

```sql
(T2, ...) LEFT JOIN (T1, ...) ON P(T1, ..., T2, ...)
```

形式的所有内部联接表达式`T1 INNER JOIN T2 ON P(T1,T2)`都由list替换 `T1,T2`，`P(T1,T2)`作为`WHERE`条件（或嵌入联接的联接条件，如果有）的联接而联接。

当优化程序评估外部联接操作的计划时，它仅考虑计划，其中对于每个此类操作，在访问内部表之前访问外部表。由于只有这样的计划才能使用嵌套循环算法执行外部联接，因此优化器的选择受到限制。

考虑这种形式的查询，其中`R(T2)` 大大缩小了table中匹配行的数量 `T2`：

```sql
SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
```

如果查询以书面形式执行，则优化器别无选择，只能在限制程度`T1`更高的表之前访问限制程度较小的 表 `T2`，这可能会产生效率很低的执行计划。

相反，如果`WHERE`条件为空，则MySQL将查询转换为无外部联接操作的查询。（也就是说，它将外部联接转换为内部联接。）如果外部条件运算结果求值`FALSE`或`UNKNOWN`为该`NULL`操作生成的任何 互补行，则条件被认为是null拒绝 的。



因此，对于此外部联接：

```sql
T1 LEFT JOIN T2 ON T1.A=T2.A
```

诸如此类的条件将被拒绝为null，因为它们对于任何`NULL`补行（ `T2`列设置为`NULL`）都无法成立：

```sql
T2.B IS NOT NULL
T2.B > 3
T2.C <= T1.C
T2.B < 2 OR T2.C > 1
```

诸如此类的条件不能为空，因为它们对于`NULL`-补行可能是正确的：

```sql
T2.B IS NULL
T1.B < 3 OR T2.B IS NOT NULL
T1.B < 3 OR T2.B > 3
```

检查外部联接操作的条件是否为空的通用规则很简单：

- 它的形式为`A IS NOT NULL`，其中 `A`是任何内部表的属性
- 这是一个谓词，包含对内部表的引用，该内部表的计算结果为何`UNKNOWN`时其参数之一为`NULL`
- 它是一个包含空值拒绝条件作为合取词的连词
- 它是零值拒绝条件的析取

对于查询中的一个外部联接操作，条件可以为null拒绝，而对于另一项则不能为null。在此查询中，`WHERE`第二个外部联接操作的条件为空，但第一个条件的条件为空：

```sql
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C > 0
```

如果`WHERE`查询中的外部联接操作拒绝该条件为空，则将外部联接操作替换为内部联接操作。

例如，在前面的查询中，第二个外部联接被拒绝为空，并且可以由内部联接代替：

```sql
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C > 0
```

对于原始查询，优化器仅评估与单个表访问顺序兼容的计划 `T1,T2,T3`。对于重写的查询，它还会考虑访问顺序 `T3,T1,T2`。

一个外部联接操作的转换可能会触发另一个外部联接操作的转换。因此，查询：

```sql
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C > 0
```

首先转换为查询：

```sql
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C > 0
```

相当于查询：

```sql
SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B
```

其余的外部联接操作也可以由内部联接代替，因为该条件`T3.B=T2.B` 被拒绝为空。这导致根本没有外部联接的查询：

```sql
SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B
```

有时，优化器成功替换了嵌入的外部联接操作，但是无法转换嵌入的外部联接。以下查询：

```sql
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0
```

转换为：

```sql
SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0
```

只能将其重写为仍包含嵌入外部联接操作的表单：

```sql
SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C > 0
```

在查询中转换嵌入式外部联接操作的任何尝试都必须考虑将外部联接嵌入条件的联接 `WHERE`条件。在此查询中，`WHERE`嵌入式外部联接的 条件不为空，但嵌入外部联接的联接条件`T2.A=T1.A AND T3.C=T1.C`为空：

```sql
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D > 0 OR T1.D > 0
```

因此，查询可以转换为：

```sql
SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D > 0 OR T1.D > 0
```

#### 8.2.1.10多范围读取优化

当表较大且未存储在存储引擎的高速缓存中时，在辅助索引上使用范围扫描来读取行会导致对表的许多随机磁盘访问。通过磁盘扫描多范围读取（MRR）优化，MySQL尝试通过首先仅扫描索引并收集相关行的键来减少用于范围扫描的随机磁盘访问次数。然后对键进行排序，最后使用主键的顺序从基表中检索行。磁盘扫描MRR的动机是减少随机磁盘访问的次数，而是对基表数据进行更顺序的扫描。

多范围读取优化具有以下优点：

- MRR使基于索引元组的数据行可以顺序访问，而不是以随机顺序访问。服务器获取一组满足查询条件的索引元组，并根据数据行ID顺序对它们进行排序，然后使用排序后的元组按顺序检索数据行。这使得数据访问更加高效且成本更低。
- 对于需要通过索引元组访问数据行的操作（例如范围索引扫描和使用索引作为联接属性的等联接）的操作，MRR支持对键访问请求的批处理。MRR在一系列索引范围内进行迭代以获得合格的索引元组。随着这些结果的累积，它们将用于访问相应的数据行。在开始读取数据行之前不必获取所有索引元组。

以下方案说明了MRR优化何时可以发挥优势：

方案A：MRR可用于`InnoDB`和 `MyISAM`索引范围扫描和表相等联接的操作。

1. 索引元组的一部分累积在缓冲区中。
2. 缓冲区中的元组按其数据行ID排序。
3. 根据排序的索引元组序列访问数据行。

方案B：MRR可以 [`NDB`](https://dev.mysql.com/doc/refman/5.6/en/mysql-cluster.html)用于多范围索引扫描的表，或者在按属性执行等值联接时使用。

1. 一部分范围（可能是单键范围）累积在提交查询的中心节点上的缓冲区中。
2. 范围被发送到访问数据行的执行节点。
3. 被访问的行被打包到程序包中并发送回中心节点。
4. 收到的带有数据行的数据包将放置在缓冲区中。
5. 从缓冲区读取数据行。

使用MRR时`Extra`，[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.6/en/explain.html)输出中的列 显示 `Using MRR`。

`InnoDB`,`MyISAM`如果不需要访问整个表行以产生查询结果，则不要使用MRR。如果可以完全基于索引元组中的信息（通过[覆盖索引](https://dev.mysql.com/doc/refman/5.6/en/glossary.html#glos_covering_index)）产生结果，则为这种情况；MRR没有任何好处。

两个[`optimizer_switch`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_optimizer_switch)系统变量标志提供了使用MRR优化的接口。该`mrr`标志控制是否启用MRR。如果`mrr`启用（`on`），则该`mrr_cost_based` 标志控制优化器是尝试在使用MRR与不使用MRR之间做出基于成本的选择（`on`）还是在可能的情况下使用MRR（`off`）。默认情况下，`mrr` is`on`和`mrr_cost_based` is `on`。请参见 [第8.9.2节“可切换的优化”](https://dev.mysql.com/doc/refman/5.6/en/switchable-optimizations.html)。

对于MRR，存储引擎将[`read_rnd_buffer_size`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_read_rnd_buffer_size)系统变量的值 用作可为其缓冲区分配多少内存的准则。引擎最多使用 [`read_rnd_buffer_size`](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_read_rnd_buffer_size)字节，并确定要在一次通过中处理的范围数。